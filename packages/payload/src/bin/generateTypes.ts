import fs from 'fs'
import { compile } from 'json-schema-to-typescript'

import type { SanitizedConfig } from '../config/types.js'

import { configToJSONSchema } from '../utilities/configToJSONSchema.js'
import { getLogger } from '../utilities/logger.js'

export async function generateTypes(
  config: SanitizedConfig,
  options?: { log: boolean },
): Promise<void> {
  const logger = getLogger('payload', 'sync')
  const outputFile = process.env.PAYLOAD_TS_OUTPUT_PATH || config.typescript.outputFile

  const shouldLog = options?.log ?? true

  if (shouldLog) {
    logger.info('Compiling TS types for Collections and Globals...')
  }

  const jsonSchema = configToJSONSchema(config, config.db.defaultIDType)

  const declare = `declare module 'payload' {\n  export interface GeneratedTypes extends Config {}\n}`
  const declareWithTSIgnoreError = `declare module 'payload' {\n  // @ts-ignore \n  export interface GeneratedTypes extends Config {}\n}`

  let compiled = await compile(jsonSchema, 'Config', {
    bannerComment:
      '/* tslint:disable */\n/* eslint-disable */\n/**\n* This file was automatically generated by Payload.\n* DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n* and re-run `payload generate:types` to regenerate this file.\n*/',
    style: {
      singleQuote: true,
    },
    // Generates code for $defs that aren't referenced by the schema. Reason:
    // If a field defines an interfaceName, it should be included in the generated types
    // even if it's not used by another type. Reason: the user might want to use it in their own code.
    unreachableDefinitions: true,
  })

  const modifiedLines = []

  let isCollectionsSelectToken = false
  let isSelectTypeToken = false

  for (const line of compiled.split('\n')) {
    let newLine = line
    if (line === `  collectionsSelect?: {` || line === `  globalsSelect?: {`) {
      isCollectionsSelectToken = true
    }

    if (isCollectionsSelectToken) {
      if (line === '  };') {
        isCollectionsSelectToken = false
      } else {
        // replace <posts: PostsSelect;> with <posts: PostsSelect<true> | PostsSelect<false;>
        newLine = line.replace(/(['"]?\w+['"]?):\s*(\w+);/g, (_, variable, type) => {
          return `${variable}: ${type}<false> | ${type}<true>;`
        })
      }
    }

    // eslint-disable-next-line regexp/no-unused-capturing-group
    if (line.match(/via the `definition` "([\w-]+_select)"/g)) {
      isSelectTypeToken = true
    }

    if (isSelectTypeToken) {
      if (line.startsWith('export interface')) {
        // add generic to the interface
        newLine = line.replace(/(export interface\s+\w+)(\s*\{)/g, '$1<T>$2')
      } else {
        // replace booleans with T on the line
        newLine = line.replace(/(?<!\?)\bboolean\b/g, 'T')

        if (line === '}') {
          isSelectTypeToken = false
        }
      }
    }

    modifiedLines.push(newLine)
  }

  compiled = modifiedLines.join('\n')

  if (config.typescript.declare !== false) {
    if (config.typescript.declare?.ignoreTSError) {
      compiled += `\n\n${declareWithTSIgnoreError}`
    } else {
      compiled += `\n\n${declare}`
    }
  }

  // Diff the compiled types against the existing types file
  try {
    const existingTypes = fs.readFileSync(outputFile, 'utf-8')

    if (compiled === existingTypes) {
      return
    }
  } catch (_) {
    // swallow err
  }

  fs.writeFileSync(outputFile, compiled)
  if (shouldLog) {
    logger.info(`Types written to ${outputFile}`)
  }
}
